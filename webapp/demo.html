<!doctype html>

<meta charset="utf-8">
<title>Dagre Interactive Demo</title>

<style>
text {
  font: 300 16px "Helvetica Neue";
}

rect {
  fill: #fff;
}

#node > rect {
  stroke-width: 3px;
  stroke: #333;
  fill: none;
}

#node:hover {
  cursor: pointer;
  opacity: 0.4;
}

#edge rect {
  fill: #fff
}

#edge path {
  fill: none;
  stroke: #333;
  stroke-width: 1.5px;
}

#edge:hover {
  cursor: pointer;
  opacity: 0.4;
}



</style>

<style>
h1, h2 {
  color: #333;
}

textarea {
  width: 800px;
}


.error {
  color: red;
}

svg {
  border: 1px solid #999;
}
</style>

<form>
  <textarea id="inputGraph" rows="5" style="display: block" onKeyUp="MainGraph.tryDraw();">
/* Example */
digraph {
    A [label="<div style='padding: 10px;'>A <span style='font-size:32px'>Big</span> <span style='color:red;'>HTML</span> Source!</div>"];
    
    D [subgraph = true];
    E [label="A blue sink"];
    A -> B -> C;
    B -> D -> E;
    C -> E;
    A -> D [label="<div>A multi-rank <span style='color:blue;'>HTML</span> edge!</div>"];
}
  </textarea>
  <textarea id="inputGraphTest" rows="5" style="display: block" onKeyUp="MainGraph.tryDraw();">
/* Example */
digraph {
    F [label="<div style='padding: 10px;'>A <span style='font-size:32px'>Big</span> <span style='color:red;'>HTML</span> Source!</div>"];
    G;
    H [label="A blue sink"];
    F -> G -> H;
    G -> H -> I;
    H -> F;

}
  </textarea>
</form>

<h2>Graph Visualization</h2>

<svg width=800 height=600>
  <defs>
    <marker id="arrowhead"
            viewBox="0 0 10 10"
            refX="8"
            refY="5"
            markerUnits="strokeWidth"
            markerWidth="8"
            markerHeight="5"
            orient="auto"
            style="fill: #333">
      <path d="M 0 0 L 10 5 L 0 10 z"></path>
    </marker>
  </defs>
</svg>

<script src="http://d3js.org/d3.v2.min.js"></script>
<script src="dagre.js"></script>

<script>
// Input related code goes here

Graph = function(svg, svgGroup, GraphId, InputId){

	this.nodes;
	this.edges;
	this.id = GraphId;
	this.inputGraph = document.querySelector(InputId);

	this.svg = svg;

	this.svgGroup = svgGroup;
	this.clickNodeList = new Array();
	this.subGraphList = new Array();

	this.tryDraw();
	if(this.id=="Main")
	{
		var self = this;
		  this.svg.call(d3.behavior.zoom().on("zoom", function redraw() {
			  self.svgGroup.attr("transform",
          "translate(" + d3.event.translate + ")"
          + " scale(" + d3.event.scale + ")");
          }));
	}
	

}

Graph.prototype.tryDraw = function() {
  var result;
 
    this.inputGraph.setAttribute("class", "");

    try {
      result = dagre.dot.toObjects(this.inputGraph.value);
      result.edges.forEach(function(e) { if (!e.label) { e.label = ""; } });
    } catch (e) {
      this.inputGraph.setAttribute("class", "error");
    }

    if (result) {
      result.nodes.forEach(function(node) {
        node.inEdges = [];
        node.outEdges = [];
      });
      
      result.edges.forEach(function(edge) {
        edge.source.outEdges.push(edge);
        edge.target.inEdges.push(edge);
      });
      this.subGraphList=[];
  
      this.draw(result.nodes, result.edges);
    
  }
}

Graph.prototype.draw = function(nodeData, edgeData) {
  // D3 doesn't appear to like rebinding with the same id but a new object,
  // so for now we remove everything.
  
  var self=this;
  this.svgGroup.selectAll("*").remove();

  this.nodes = this.svgGroup
    .selectAll("g ."+this.id+"-node")
    .data(nodeData, function(d) { return d.id; });
    
 
  var nodeEnter = this.nodes
    .enter()
    .append("g")
      .attr("class",this.id+"-node")
      .attr("id", "node")
      .each(function(d) { d.nodePadding = 10; });
      
  nodeEnter.append("rect");
  this.addLabels(nodeEnter);
  
  this.nodes.on("click", function(d) {
	
		
		if(self.clickNodeList[d.id])
			self.clickNodeList[d.id] =false;
		else
			self.clickNodeList[d.id]= true;
		if(!d.subgraph)
			self.clickNodeList[d.id] =false;
		
		self.tryDraw();
	  })
	  
  this.nodes.exit().remove();

  this.edges = this.svgGroup
    .selectAll("g ."+this.id+"-edge")
    .data(edgeData, function(d) {  return d.id; });

  var edgeEnter = this.edges
    .enter()
    .append("g")
      .attr("class", this.id+"-edge")
      .attr("id", "edge")
      .each(function(d) { d.nodePadding = 0; })
 
  edgeEnter
    .append("path")
      .attr("marker-end", "url(#arrowhead)");

  this.addLabels(edgeEnter);
  

  this.edges.on("click", function(d) {
		console.log(d.id);
		
		self.Draw();
	  })
	  
  this.edges.exit().remove();

  this.recalcLabels();

  // Add zoom behavior to the SVG canvas


  	// Run the actual layout
  	var layout = dagre.layout()
  	    .nodeSep(50)
    .edgeSep(10)
    .rankSep(50)
    .nodes(nodeData)
    .edges(edgeData)
    .debugLevel(0)
    .run();

    // Ensure that we have at least two points between source and target
  	this.edges.each(function(d) { self.ensureTwoControlPoints(d); });
   

   // Re-render
  	this.update();
}

Graph.prototype.addLabels = function(selection) {
  var self= this;
  var labelGroup = selection
    .append("g")
      .attr("class", this.id+"-label");

   labelGroup.append("rect").attr("id","labelrect").attr("Apple",self.id);
      
  var foLabel = labelGroup
    .filter(function(d) { return d.label[0] === "<"; })	//두 값이 동등해야 같다
    .append("foreignObject")
      .attr("class", "htmllabel");

  foLabel
    .append("xhtml:div")
      .style("float", "left");

  labelGroup
    .filter(function(d) { 
        return (d.label[0] !== "<")&&(!self.clickNodeList[d.id]); }) //동등하지 않은 경우 TEXT 형태로 
    .append("text");
    
   
   //SubGraphLabel 추가 
   	var SubArray = new Array();
    labelGroup
    .filter(function(d) { 
        return (d.subgraph)&&(self.clickNodeList[d.id]); }) 
    .append("svg")
    .attr("class",function(d) { 
    	SubArray.push("subgraph-"+d.id);
    return "subgraph-"+d.id; }); //있는 놈들 서브 그래프 수집

    for(var i=0;i<SubArray.length;i++)
    {
    	
	 	var subSvg = d3.select("."+SubArray[i]);
	 	var subGroup = subSvg.append("g").attr("id",SubArray[i]);
	 	this.subGraphList.push(new Graph(subSvg, subGroup, SubArray[i],"#inputGraphTest"));
	 	subSvg.attr("visibility","hidden");
	 	var svgBBox = this.subGraphList[i].svg.node().getBBox();
	 	console.log(svgBBox);
	 	var Test = labelGroup.select("#labelrect");
	 	console.log(Test);	
	}
  
   
    
 
}    

Graph.prototype.recalcLabels = function() {
	var self = this;
  var labelGroup = this.svgGroup.selectAll("g ."+this.id+"-label"); //class가 라벨인  녀석들 모두 선택 

  var foLabel = labelGroup
    .selectAll(".htmllabel")
    // TODO find a better way to get the dimensions for foriegnObjects
    .attr("width", "10000");	//Web 객체의 사이즈를 알지 못하므로 width를 크게 설정

  foLabel
    .select("div")
      .html(function(d) { 
      return d.label; })
      .each(function(d) {
        d.width = this.clientWidth;
        d.height = this.clientHeight;
        d.nodePadding = 0;
      });

  foLabel
    .attr("width", function(d) {  return d.width; })
    .attr("height", function(d) { return d.height; });

  var textLabel = labelGroup
    .filter(function(d) { return (d.label[0] !== "<")&&(!self.clickNodeList[d.id]); });

  textLabel
    .select("text")
      .attr("text-anchor", "left")
        .append("tspan")
        .attr("dy", "1em")
        .text(function(d) { return d.label || " "; });



  labelGroup
    .each(function(d) {
      var bbox = this.getBBox();
      d.bbox = bbox;
      d.width = bbox.width + 2 * d.nodePadding;
      d.height = bbox.height + 2 * d.nodePadding;
    });
    
    
    
}

Graph.prototype.ensureTwoControlPoints = function(d) {
  var points = d.dagre.points;

  if (!points.length) {
    var s = d.source.dagre;
    var t = d.target.dagre;
    points.push({ x: (s.x + t.x) / 2, y: (s.y + t.y) / 2 });
  }

  if (points.length === 1) {
    points.push({ x: points[0].x, y: points[0].y });
  }

}

Graph.prototype.update = function() {
  	
  	var self = this;
 
 
 
  	this.nodes 
    	.attr("transform", function(d) {
     	 return "translate(" + d.dagre.x + "," + d.dagre.y +")"; })
      .selectAll("g ."+this.id+"-node rect")
      .attr("x", function(d) { return -(d.bbox.width / 2 + d.nodePadding); })
      .attr("y", function(d) { return -(d.bbox.height / 2 + d.nodePadding); })
      .attr("width", function(d) { return d.width; })
      .attr("height", function(d) { return d.height; });

      this.edges
    	.selectAll("path")
    	.attr("d", function(d) {
      	var points = d.dagre.points.slice(0);
      	var source = dagre.util.intersectRect(d.source.dagre, points[0]);
      	var target = dagre.util.intersectRect(d.target.dagre, points[points.length - 1]);
      	points.unshift(source);
      	points.push(target);
      	return d3.svg.line()
       	 .x(function(e) { return e.x; })
       	 .y(function(e) { return e.y; })
       	 .interpolate("linear")
       	 (points);
        });

    this.svgGroup
 	   .selectAll("g."+this.id+"-label rect")
  	  .attr("x", function(d) { return -d.nodePadding; })
  	  .attr("y", function(d) { return -d.nodePadding; })
   	 .attr("width", function(d) { return d.width; })
   	 .attr("height", function(d) { return d.height; });



    this.nodes
   	 .selectAll("g ."+this.id+"-label")
   	 .attr("transform", function(d) { return "translate(" + (-d.bbox.width / 2) + "," + (-d.bbox.height / 2) + ")"; });


   	 
   	 
    this.edges
    .selectAll("g ."+this.id+"-label")
    .attr("transform", function(d) {
      var points = d.dagre.points;
      var x = (points[0].x + points[1].x) / 2;
      var y = (points[0].y + points[1].y) / 2;
      return "translate(" + (-d.bbox.width / 2 + x) + "," + (-d.bbox.height / 2 + y) + ")";
      });
      
     for(var i=0;i<this.subGraphList.length;i++)
  		this.subGraphList[i].update();
}

</script>

<script>


var Mainsvg = d3.select("svg");
var MainsvgGroup = Mainsvg.append("g").attr("transform", "translate(5, 5)");
var MainGraph = new Graph(Mainsvg,MainsvgGroup,"Main","#inputGraph");

</script>

<script>

</script>
